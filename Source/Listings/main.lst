C51 COMPILER V9.60.0.0   MAIN                                                              12/06/2022 00:19:29 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          
   2            #include<main.h>
   3          
   4            /*================================Funtion prototype=========================================*/
   5            void extract_buff();
   6            void calc_disp();
   7            void reset_buff();
   8            void reverse(char* str, int len);
   9            int intToStr(int x, char str[], int d);
  10            void ftoa(float n, char* res, int afterpoint);
  11            double round(double soCanLamTron, int chuSo);
  12            void xuly();
  13            void disp_error();
  14            void disp_over();
  15            /*========================================END=================================================*/
  16            
  17            
  18            
  19            /*====================================Variables==============================================*/
  20            /*Data (252.1B) include: Idata (131Bytes) + Data (remain 16bytes) + etc...
  21            xdata: rat nhieu
  22            float, double, long double,long, unsigned long = 4 bytes
  23            int: 2bytes
  24            char, usigned char: 1byte
  25            xdata volatile int pointer =0;
  26          
  27            max float 32767 => Du 16bit nhung phai sd bit lam bit dau, exp, k dc luu tai xdata\
  28            buff result cung k dc luu tai xdata
  29            data float kq = 320.967545454; 
  30            */
  31            
  32            
  33            idata unsigned char buff[25];   // Buffer save string of eqution
  34            idata unsigned char tt1[10];
  35            idata unsigned char tt2[10];    // Two string buffers save two oprerants of Equation
  36            idata volatile int pointer = 0; //Pointer to devide buff string
  37            idata unsigned char buff_result[10];  //Ket qua dc luu vao mang ki tu
  38            idata unsigned char error[]= "Math Error";
  39            idata int flag_error = 0;
  40            idata int negative = 0;
  41            idata int over_mem = 0;
  42            idata unsigned char over_mes[]="Memory Over";
  43            
  44            data float f_operant = 0;
  45            data float l_operant = 0;     //Two interger for store two oprerants in float
  46            data unsigned char sign;      // Store sign of equation
  47            data float result = 0;        // Store the result
  48            data unsigned char key = 0;   // Where key pressed is located 
  49            /*==========================================END===============================================*/
  50          
  51          void main()
  52          {
  53   1        reset_buff();
  54   1        LCD_Init();           //Thiet lap cau hinh cho LCD
C51 COMPILER V9.60.0.0   MAIN                                                              12/06/2022 00:19:29 PAGE 2   

  55   1        LCD_Clear();
  56   1        LCD_Gotoxy(0,0);
  57   1        LCD_PutString("Hi there!");
  58   1        delay_ms(1000);
  59   1        LCD_Clear_Blink();
  60   1        while(1)
  61   1        {
  62   2          key = KEY4X4_GetKey();      //nhan thu tu phim nhan
  63   2          if (key!=0){                //phat hien co phim nhan
  64   3            if (key !='C'){
  65   4              LCD_PutChar(key); 
  66   4              delay_ms(250);
  67   4              buff[pointer] = key;
  68   4              pointer++;
  69   4              if (key =='='){
  70   5                extract_buff();
  71   5                calc_disp();
  72   5                reset_buff();       //Tinh xong xoa bo nho dem
  73   5              }
  74   4            }
  75   3            else{ 
  76   4              LCD_Clear_Blink();  //Nhan C => Xoa man hinh
  77   4              reset_buff();
  78   4            }
  79   3          } 
  80   2        }
  81   1      }
  82          
  83          void extract_buff(){ 
  84   1        int k = 0;
  85   1        pointer = 0;          // 656565+65545=
  86   1        
  87   1        while(buff[pointer]!='+'&&buff[pointer]!='-'&&buff[pointer]!='X'&&buff[pointer]!=':'){
  88   2          tt1[pointer] = buff[pointer];
  89   2          pointer++;
  90   2        }
  91   1        sign = buff[pointer];
  92   1        pointer++;
  93   1        k = pointer;
  94   1        while(buff[pointer] != '='){
  95   2          tt2[pointer - k] = buff[pointer];
  96   2          pointer++;
  97   2        }
  98   1      }
  99          
 100          void calc_disp(){
 101   1        int i = 0;
 102   1        idata unsigned char verify[10];
 103   1        f_operant = atoi(tt1);
 104   1        l_operant = atoi(tt2);
 105   1        /*ftoa(f_operant,buff_result,3);
 106   1        //LCD_Clear();
 107   1        LCD_control_off_xy(0,1);
 108   1        LCD_PutString(buff_result);
 109   1        delay_ms(10000);
 110   1        */
 111   1        
 112   1        switch (sign){
 113   2          case '+':
 114   2            result = f_operant + l_operant;
 115   2            break;
 116   2          case '-':
C51 COMPILER V9.60.0.0   MAIN                                                              12/06/2022 00:19:29 PAGE 3   

 117   2            result = f_operant - l_operant;
 118   2            break;
 119   2          case 'X':
 120   2            result = f_operant * l_operant;
 121   2            break;
 122   2          case ':':
 123   2            if (l_operant !=0){
 124   3            result = f_operant / l_operant;
 125   3            }
 126   2            else flag_error = 1;
 127   2            break;
 128   2          default:
 129   2            flag_error = 1;
 130   2        }
 131   1        ftoa(result,verify,3);
 132   1        for (i=0;i<=strlen(verify);i++){
 133   2          if (verify[i] == '/'||verify[i] == '+'||verify[i] == '-')
 134   2            over_mem = 1;
 135   2        }
 136   1        /*if (sign =='/'){
 137   1          result = round(result,4);
 138   1        }*/
 139   1        if (sign == '/'){
 140   2          result = round(result,3);
 141   2          xuly();
 142   2        }
 143   1        else
 144   1          xuly();
 145   1        memset(verify,0,strlen(verify));
 146   1      }
 147          void xuly(){
 148   1          if (result < 0 && flag_error == 0 && over_mem == 0){
 149   2            result = -result;
 150   2            ftoa(result,buff_result,3);
 151   2            //LCD_Clear();
 152   2            LCD_control_off_xy(0,1);
 153   2            LCD_PutChar('-');
 154   2            LCD_PutString(buff_result);
 155   2          }
 156   1          else if(result >=0 && flag_error == 0 && over_mem == 0){
 157   2            ftoa(result,buff_result,3);
 158   2            //LCD_Clear();
 159   2            LCD_control_off_xy(0,1);
 160   2            LCD_PutString(buff_result);
 161   2          }
 162   1          else {
 163   2            if (over_mem == 1 && flag_error == 0)
 164   2              disp_over();
 165   2            else
 166   2              disp_error();
 167   2          }
 168   1      }
 169          void disp_error(){
 170   1        LCD_Clear();
 171   1        LCD_control_off_xy(0,0);
 172   1        LCD_PutString(error);
 173   1      }
 174          void disp_over(){
 175   1        LCD_Clear();
 176   1        LCD_control_off_xy(0,0);
 177   1        LCD_PutString(over_mes);
 178   1      }
C51 COMPILER V9.60.0.0   MAIN                                                              12/06/2022 00:19:29 PAGE 4   

 179          double round(double soCanLamTron, int chuSo)
 180          {
 181   1          int temp;
 182   1          int i, result = 1;
 183   1         
 184   1          //Pow
 185   1          for(i = 1; i <= chuSo; i++)
 186   1          {
 187   2              result *= 10;
 188   2          }
 189   1          temp = soCanLamTron*result;
 190   1          if(temp%10 >= 5)
 191   1          {
 192   2              temp += 1;
 193   2          }
 194   1          soCanLamTron = (double)temp/result;
 195   1          return soCanLamTron;
 196   1      }
 197          void reset_buff(){
 198   1        memset(buff,0,strlen(buff));
 199   1        memset(tt1,0,strlen(tt1));
 200   1        memset(tt2,0,strlen(tt2));
 201   1        memset(buff_result,0,strlen(buff_result));
 202   1        sign = 'n';
 203   1        pointer = 0;
 204   1        flag_error = 0;
 205   1        over_mem = 0;
 206   1      }
 207            
 208          // Reverses a string 'str' of length 'length'
 209          void reverse(char* str, int len)
 210          {
 211   1        int i = 0, j = len - 1, temp;
 212   1        while (i < j) {
 213   2          temp = str[i];
 214   2          str[i] = str[j];
 215   2          str[j] = temp;
 216   2          i++;
 217   2          j--;
 218   2        }
 219   1      }
 220          
 221          // Converts a given integer x to string str[].
 222          // d is the number of digits required in the output.
 223          // If d is more than the number of digits in x,
 224          // then 0s are added at the beginning.
 225          int intToStr(int x, char str[], int d){
 226   1        int i = 0;
 227   1        while (x) {
 228   2        str[i++] = (x % 10) + '0';
 229   2        x = x / 10;
 230   2      }
 231   1      
 232   1      // If number of digits required is more, then
 233   1      // add 0s at the beginning
 234   1      while (i < d) str[i++] = '0';
 235   1      reverse(str, i);
 236   1      str[i] = '\0';
 237   1      return i;
 238   1      }
 239          
 240          // Converts a floating-point/double number to a string.
C51 COMPILER V9.60.0.0   MAIN                                                              12/06/2022 00:19:29 PAGE 5   

 241          void ftoa(float n, char* res, int afterpoint){
 242   1      // Extract integer part
 243   1      int ipart = (int)n;
 244   1      // Extract floating part
 245   1      float fpart = n - (float)ipart;
 246   1      // convert integer part to string
 247   1      int i = intToStr(ipart, res, 0);
 248   1      // check for display option after point
 249   1      if (afterpoint != 0){
 250   2        res[i] = '.'; // add dot
 251   2        // Get the value of fraction part upto given no.
 252   2        // of points after dot. The third parameter
 253   2        // is needed to handle cases like 233.007
 254   2        fpart = fpart * pow(10, afterpoint);
 255   2        intToStr((int)fpart, res + i + 1, afterpoint);
 256   2      }
 257   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1468    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14      45
   IDATA SIZE       =     86      10
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
